<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Digitaler Fragebogen</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #question { font-size: 18px; margin-bottom: 15px; }
    button { margin: 5px; padding: 8px 16px; }
    textarea, select, input[type=text], input[type=number], input[type=date] {
      width: 100%; margin: 5px 0; padding: 6px;
    }
    #upload, #attributes { margin-top: 20px; padding: 10px; border: 1px solid #ccc; display:none; }
    #done { margin-top: 20px; }
  </style>
</head>
<body>

<h2>Fragebogen-8 (Dropdown-Fix)</h2>
<div id="question"></div>
<button onclick="answer('Ja')">Ja</button>
<button onclick="answer('Nein')">Nein</button>

<div id="upload">
  <p><a id="upload-link" href="#" target="_blank">→ Datei hier hochladen</a></p>
</div>

<div id="attributes">
  <h4>Zusätzliche Angaben</h4>
  <form id="attrForm"></form>
  <button onclick="nextQuestion()">Weiter</button>
</div>

<div id="done" style="display:none;">
  <h3>Vielen Dank für Ihre Teilnahme!</h3>
</div>

<script>
/* ========== EMAILJS ========== */
(function() { emailjs.init("ueUbQfFPpdM5MC2z2"); })();
const SERVICE_ID = "service_b074ymd";
const TEMPLATE_ID = "template_omwd93k";

/* ========== DATENQUELLEN ========== */
const EXCEL_URL = "https://raw.githubusercontent.com/Geralf1960/formular4/main/Empfaenger-Upload-Links-2.xlsx";
const QUESTIONS_URL = "https://raw.githubusercontent.com/Geralf1960/formular4/main/Fragen.xlsx";

let questions = [];
let answers = [];
let currentNode = null;
let uploadLinks = {};

/* Hilfsfunktion: slugify für IDs */
function slugify(s) {
  return s.toString().toLowerCase().replace(/\s+/g,'_').replace(/[^\w\-]/g,'');
}

/* ======== FRAGEN AUS EXCEL LADEN ======== */
async function loadQuestionsFromExcel() {
  const response = await fetch(QUESTIONS_URL);
  const arrayBuffer = await response.arrayBuffer();
  const workbook = XLSX.read(arrayBuffer, { type: "array" });
  const sheet = workbook.Sheets[workbook.SheetNames[0]];
  const json = XLSX.utils.sheet_to_json(sheet);

  const map = {};
  json.forEach(row => {
    map[row.ID] = {
      id: row.ID,
      text: row.Frage,
      upload: row.Upload && row.Upload.toString().toLowerCase() === "ja",
      attributes: row.Attribute ? row.Attribute.split(";").map(x => x.trim()).filter(Boolean) : [],
      sub: []
    };
  });

  const roots = [];
  json.forEach(row => {
    if (row.ParentID && map[row.ParentID]) {
      map[row.ParentID].sub.push(map[row.ID]);
    } else {
      roots.push(map[row.ID]);
    }
  });
  questions = roots;
}

/* ======== UPLOAD-LINKS LADEN ======== */
async function loadExcel() {
  const response = await fetch(EXCEL_URL);
  const arrayBuffer = await response.arrayBuffer();
  const workbook = XLSX.read(arrayBuffer, { type: "array" });
  const sheet = workbook.Sheets[workbook.SheetNames[0]];
  const json = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });

  json.slice(1).forEach(row => {
    if (row[0] && row[1]) {
      uploadLinks[row[0].toString().trim().toLowerCase()] = row[1].toString().trim();
    }
  });
}

/* ======== START ======== */
async function startForm() {
  await loadExcel();
  await loadQuestionsFromExcel();

  const params = new URLSearchParams(window.location.search);
  const user = params.get("user");
  if (!user || !uploadLinks[user.toLowerCase()]) {
    document.getElementById("question").innerText = "Kein Upload-Link für diesem Benutzer gefunden.";
    return;
  }
  currentNode = { sub: questions, idx: 0, user: user.toLowerCase() };
  showQuestion();
}

/* ======== ANZEIGE / NAVIGATION ======== */
function showQuestion() {
  document.getElementById("upload").style.display = "none";
  document.getElementById("attributes").style.display = "none";

  if (!currentNode || currentNode.idx >= currentNode.sub.length) {
    finishForm();
    return;
  }
  const q = currentNode.sub[currentNode.idx];
  document.getElementById("question").innerText = q.text;
}

/* ======== ANTOWRT VERARBEITEN ======== */
function answer(ans) {
  const q = currentNode.sub[currentNode.idx];
  answers.push({ frage: q.text, antwort: ans, attribute: {}, kommentar: "" });

  if (ans === "Ja") {
    // Upload anzeigen falls gesetzt
    if (q.upload) {
      document.getElementById("upload-link").href = uploadLinks[currentNode.user];
      document.getElementById("upload").style.display = "block";
    }
    // Attribute anzeigen falls vorhanden
    if (q.attributes.length > 0) {
      renderAttributes(q.attributes);
      document.getElementById("attributes").style.display = "block";
      return; // warte auf Weiter()
    }
  }

  // sonst: weiter
  currentNode.idx++;
  showQuestion();
}

/* ======== Attribute-Parsing und Rendering ========
   Erwartetes Format (Excel, Spalte Attribute):
   - "Farbe:Text; Baujahr:Number; Priorität:Dropdown(Niedrig,Mittel,Hoch); Aktiv:boolean; Notiz:Textarea"
   - Synonyme für Dropdown: Dropdown(...) oder Select(...)
===============================================*/
function parseAttributeDef(def) {
  // def z.B. "Priorität:Dropdown(Niedrig,Mittel,Hoch)"
  const parts = def.split(":");
  const label = parts.shift().trim();
  const typeRaw = parts.join(":").trim() || "text";
  const m = typeRaw.match(/^([a-zA-Z]+)\s*(?:\((.*)\))?$/); // base and optional args
  const base = m ? m[1].toLowerCase() : "text";
  const args = m && m[2] ? m[2].trim() : null;
  // split args by comma or semicolon
  const options = args ? args.split(/[,;]+/).map(s => s.trim()).filter(Boolean) : [];
  return { label, base, options };
}

function renderAttributes(attrDefs) {
  const form = document.getElementById("attrForm");
  form.innerHTML = "";

  attrDefs.forEach(def => {
    if (!def || !def.trim()) return;
    const parsed = parseAttributeDef(def);
    const id = `attr_${slugify(parsed.label)}`;
    const wrapper = document.createElement("div");
    wrapper.style.marginBottom = "8px";

    const lbl = document.createElement("label");
    lbl.htmlFor = id;
    lbl.innerText = parsed.label + ": ";
    wrapper.appendChild(lbl);

    let inputEl;

    switch (parsed.base) {
      case "number":
        inputEl = document.createElement("input");
        inputEl.type = "number";
        inputEl.id = id;
        inputEl.dataset.label = parsed.label;
        break;

      case "date":
        inputEl = document.createElement("input");
        inputEl.type = "date";
        inputEl.id = id;
        inputEl.dataset.label = parsed.label;
        break;

      case "boolean":
        inputEl = document.createElement("select");
        inputEl.id = id;
        inputEl.dataset.label = parsed.label;
        ["", "Ja", "Nein"].forEach(v => {
          const o = document.createElement("option");
          o.value = v;
          o.textContent = v === "" ? "—" : v;
          inputEl.appendChild(o);
        });
        break;

      case "dropdown":
      case "select":
        inputEl = document.createElement("select");
        inputEl.id = id;
        inputEl.dataset.label = parsed.label;
        // placeholder
        const ph = document.createElement("option");
        ph.value = "";
        ph.textContent = "Keine Auswahl";
        inputEl.appendChild(ph);
        parsed.options.forEach(opt => {
          const o = document.createElement("option");
          o.value = opt;
          o.textContent = opt;
          inputEl.appendChild(o);
        });
        break;

      case "checkbox":
        // If options provided -> multiple checkboxes, else single checkbox (boolean)
        if (parsed.options.length > 0) {
          const container = document.createElement("div");
          parsed.options.forEach((opt, i) => {
            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.id = `${id}_${i}`;
            cb.value = opt;
            cb.dataset.label = parsed.label;
            const lblcb = document.createElement("label");
            lblcb.htmlFor = cb.id;
            lblcb.style.marginLeft = "6px";
            lblcb.textContent = opt;
            const row = document.createElement("div");
            row.appendChild(cb);
            row.appendChild(lblcb);
            container.appendChild(row);
          });
          inputEl = container;
        } else {
          inputEl = document.createElement("input");
          inputEl.type = "checkbox";
          inputEl.id = id;
          inputEl.dataset.label = parsed.label;
        }
        break;

      case "textarea":
        inputEl = document.createElement("textarea");
        inputEl.id = id;
        inputEl.rows = 3;
        inputEl.dataset.label = parsed.label;
        break;

      case "upload":
        inputEl = document.createElement("input");
        inputEl.type = "file";
        inputEl.id = id;
        inputEl.dataset.label = parsed.label;
        break;

      default:
        // text fallback
        inputEl = document.createElement("input");
        inputEl.type = "text";
        inputEl.id = id;
        inputEl.dataset.label = parsed.label;
        break;
    }

    // append input element(s)
    wrapper.appendChild(inputEl);
    form.appendChild(wrapper);
  });
}

/* ======== WEITER: Attribute auslesen und Frage fortsetzen ======== */
function nextQuestion() {
  const form = document.getElementById("attrForm");
  const q = currentNode.sub[currentNode.idx];
  if (!q) return;

  // build label -> values map
  const valueMap = {};
  // handle all input/select/textarea inside form
  const elements = form.querySelectorAll("input, select, textarea, div");
  elements.forEach(el => {
    // if it's a container div (multiple checkboxes), handle its checkboxes
    if (el.tagName === "DIV") {
      const checkboxes = el.querySelectorAll("input[type=checkbox]");
      if (checkboxes.length) {
        const label = checkboxes[0].dataset.label || ("Mehrfach");
        const vals = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);
        if (vals.length) valueMap[label] = (valueMap[label] || []).concat(vals);
      }
      return;
    }

    const label = el.dataset.label || el.id || "Wert";
    let val = null;
    if (el.type === "checkbox") {
      if (el.checked) val = el.value || "Ja";
    } else if (el.type === "file") {
      val = (el.files && el.files.length) ? el.files[0].name : "";
    } else {
      val = el.value ?? "";
    }
    if (val !== "" && val !== null) {
      // accumulate multiple inputs with same label
      if (!valueMap[label]) valueMap[label] = [];
      valueMap[label].push(val);
    }
  });

  // append to last answer entry
  const last = answers[answers.length - 1];
  if (last) {
    Object.keys(valueMap).forEach(lbl => {
      last.attribute[lbl] = valueMap[lbl].join(", ");
    });
  }

  // hide UI and continue
  document.getElementById("attributes").style.display = "none";
  document.getElementById("upload").style.display = "none";

  currentNode.idx++;
  showQuestion();
}

/* ======== ABSCHLUSS ======== */
function finishForm() {
  document.getElementById("question").style.display = "none";
  document.getElementById("done").style.display = "block";

  const params = new URLSearchParams(window.location.search);
  const user = params.get("user");

  // prepare plain text for EmailJS
  const answerText = answers.map(a => {
    const attrs = Object.entries(a.attribute || {}).map(([k,v]) => `${k}: ${v}`).join("; ");
    return `${a.frage}\nAntwort: ${a.antwort}\n${attrs ? "Attribute: " + attrs + "\n" : ""}${a.kommentar ? "Kommentar: " + a.kommentar + "\n": ""}`;
  }).join("\n---------------------\n");

  emailjs.send(SERVICE_ID, TEMPLATE_ID, {
    from_email: user,
    answers: answerText
  }).catch(() => {
    // still finish silently
  });
}

/* ======== INIT ======== */
startForm();
</script>
</body>
</html>
